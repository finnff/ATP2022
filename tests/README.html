<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="testrapport">TestRapport</h1>
<h1
id="unit-test-1-measures-speed-calculator-.srcwheelspeedcppwsp_mod.so-bestaande-uit-.srcwheelspeedcppaaaaaaaa.cpp">Unit
Test 1 Measures Speed calculator (./src/WheelSpeedCPP/wsp_mod.so)
bestaande uit (./src/WheelSpeedCPP/aaaa/aaaa.cpp)</h1>
<h2 id="unit-test-measuredspeedcalculator">Unit Test:
MeasuredSpeedCalculator</h2>
<h3 id="motivatie">Motivatie</h3>
<p>De MeasuredSpeedCalculator is een cruciaal onderdeel van het systeem,
aangezien het de snelheid van het voertuig probeert te berekenen op
basis van de input van de WheelSpeedSensor. Een nauwkeurige
snelheidsberekening is essentieel voor het ACC systeem, waardoor het op
een veilige afstand tot het voorliggende voertuig kan blijven. Als de
MeasuredSpeedCalculator onjuiste snelheden berekent, heeft dit via de
CPU invloed op het op het GasPedaal en Remsysteem. Fouten of ongewenst
gedrag in deze 2 actuatoren kan dit leiden tot onveilige situaties en
mogelijk ongevallen. Het testen van deze component is daarom
noodzakelijk om te waarborgen dat het systeem goed functioneert en om de
veiligheid te garanderen.</p>
<h3 id="testprocedure">Testprocedure</h3>
<p>Testen of de MeasuredSpeedCalculator de snelheid van het voertuig
correct berekent op basis van verschillende
inputwaarden(Hatchback,SUV,Ferrari) van de WheelSpeedSensor,
Wieldiameter en CPR van het encoderwiel.</p>
<ol type="1">
<li>Bereid testscenario’s voor met verschillende inputwaarden voor de
WheelSpeedSensor, Wieldiameter en CPR van het encoderwiel. Gebruik
realistische waarden die overeenkomen met verschillende voertuigtypen
(bijv. Hatchback, SUV, Ferrari).</li>
<li>Voer de testscenario’s uit met behulp van de Simulator, en leg zowel
de berekende snelheden, als de TrueVehicleSpeed uit de Simulator
vast.</li>
<li>Vergelijk de berekende snelheden met de TrueVehicleSpeed, rekening
houdend met de variabelen van de verschillende soorten autos uit de
testscenario’s.</li>
<li>Controleer of de berekende snelheden binnen een acceptabele
foutmarge(+- 2.0%) van de verwachte snelheden vallen. Als dit niet het
geval is, onderzoek dan de oorzaak en pas de implementatie van de
MeasuredSpeedCalculator (of WheelSpeedSensor) aan indien nodig.</li>
<li>Herhaal de testprocedure totdat de berekende snelheden consistent
nauwkeurig(i.e. binnen de foutmarge) zijn voor alle testscenario’s.</li>
</ol>
<p>Deze testprocedure is ontworpen met verschillende belangrijke
aspecten in gedachten om de nauwkeurigheid van de snelheidsberekeningen
te waarborgen en de veiligheid van het systeem te garanderen:</p>
<ul>
<li>Realistische waarden worden gebruikt voor de inputvariabelen om de
prestaties van het systeem in de praktijk te beoordelen.</li>
<li>Het vastleggen van zowel de berekende snelheden als de
TrueVehicleSpeed stelt ons in staat om objectief de nauwkeurigheid van
de berekeningen te beoordelen.</li>
<li>Door een kleine foutmarge te gebruiken, wordt rekening gehouden met
de beperkingen van floating-point precisie en kleine
nauwkeurigheidsfouten in de sensors.</li>
<li>Het herhalen van de testprocedure zorgt voor betrouwbaarheid en
verkleint de kans op onveilige situaties of ongevallen.</li>
</ul>
<p>Door deze testprocedure te volgen, kunnen we de nauwkeurigheid van de
snelheidsberekening garanderen en voorkomen dat ongewenst gedrag van het
GasPedaal en Remsysteem leidt tot onveilige situaties en mogelijk
ongevallen.</p>
<p>HIER ONDER LEZEN HIER ONDER LEZEN HIER ONDER LEZEN HIER ONDER LEZEN
HIER ONDER LEZEN</p>
<p>De Measuresed Speed snso werkt voor alle sorten wielen, ook bij
bewegeing , hoewel in eerste we de foutmarge wel haal maar dat er nog
wel relatief veel foutmarge zit in het lezenv van de sensor:</p>
<p class="heading" id="section"></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;Param Name&quot;</span><span class="fu">:</span> <span class="st">&quot;Ferrari F69&quot;</span><span class="fu">,</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;Wheel Diameter&quot;</span><span class="fu">:</span> <span class="fl">0.71</span><span class="fu">,</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;Encoder CPR&quot;</span><span class="fu">:</span> <span class="dv">40</span><span class="fu">,</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;Param Name&quot;</span><span class="fu">:</span> <span class="st">&quot;Golf GTI/GTE&quot;</span><span class="fu">,</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;Wheel Diameter&quot;</span><span class="fu">:</span> <span class="fl">0.625</span><span class="fu">,</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;Encoder CPR&quot;</span><span class="fu">:</span> <span class="dv">45</span><span class="fu">,</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;Param Name&quot;</span><span class="fu">:</span> <span class="st">&quot;BMW X27&quot;</span><span class="fu">,</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;Wheel Diameter&quot;</span><span class="fu">:</span> <span class="fl">0.838</span><span class="fu">,</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;Encoder CPR&quot;</span><span class="fu">:</span> <span class="dv">60</span><span class="fu">,</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<p>De Measured Speed sensor is ontworpen om compatibel te zijn met
verschillende soorten wielen en bewegingsomstandigheden. Uit de eerste
testresultaten blijkt dat we binnen de gespecificeerde foutmarge van
±2.0% vallen. Hier zijn enkele voorbeeldresultaten:</p>
<ul>
<li>True Speed: 12.03, Calculated Speed: 11.99, Delta: 0.04, Delta %:
0.30%</li>
</ul>
<p>Hoewel we binnen de foutmarge zitten, is het belangrijk op te merken
dat we een interne fout van 0.3% hebben gemodelleerd voor de sensor,
zoals aangegeven op pagina 17 van de <a
href="https://www.infineon.com/dgdl/Infineon-TLE5041PLUSC-DataSheet-v01_02-EN.pdf?fileId=5546d46265f064ff016632437f574f75">Infineon-TLE5041PLUSC
datasheet</a>.</p>
<p>Hij is getest met de volgende 3 Autos:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;Param Name&quot;</span><span class="fu">:</span> <span class="st">&quot;Ferrari F69&quot;</span><span class="fu">,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;Wheel Diameter&quot;</span><span class="fu">:</span> <span class="fl">0.71</span><span class="fu">,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;Encoder CPR&quot;</span><span class="fu">:</span> <span class="dv">40</span><span class="fu">,</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;Param Name&quot;</span><span class="fu">:</span> <span class="st">&quot;Golf GTI/GTE&quot;</span><span class="fu">,</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;Wheel Diameter&quot;</span><span class="fu">:</span> <span class="fl">0.625</span><span class="fu">,</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;Encoder CPR&quot;</span><span class="fu">:</span> <span class="dv">45</span><span class="fu">,</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;Param Name&quot;</span><span class="fu">:</span> <span class="st">&quot;BMW X27&quot;</span><span class="fu">,</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;Wheel Diameter&quot;</span><span class="fu">:</span> <span class="fl">0.838</span><span class="fu">,</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;Encoder CPR&quot;</span><span class="fu">:</span> <span class="dv">60</span><span class="fu">,</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<p>De enige fouten die ik ben tegen gekomen gebeurden als ik handmatig
(via de simulator) de snelheid van het voertuig ging veranderen, en dat
de berekening van de oude snelheid al was gestart (Multi threaded
concurreny ):</p>
<figure>
<img src="img/2023-08-30-21-54-34.png" alt="img" />
<figcaption aria-hidden="true">img</figcaption>
</figure>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Code voor het toevoegen van een willekeurige fout van ± 0.3% zoals gespecificeerd in de datasheet.</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>encoder_pulses_per_second <span class="op">*=</span> <span class="dv">1</span> <span class="op">+</span> random.choice([<span class="op">-</span><span class="fl">0.003</span>, <span class="fl">0.003</span>])</span></code></pre></div>
<p>Wanneer deze sensorfout wordt verwijderd uit de simulatie, zijn de
foutmarges extreem laag, wat betekend dat onze code en C++-binding zeer
nauwkeurig zijn in het berekenen van de snelheid, ongeacht het
voertuigtype en de wielgrootte.</p>
<pre><code>True Speed: 12.300423,          Calculated Speed: 12.30042076110839, Delta: 2.2388916018911686e-06, Delta %: 1.820174478464008e-05, Elapsed Time: 0.00011110305786132812, 1/Elapsed Time: 9000.652360515021
True Speed: 12.410620000000002, Calculated Speed: 12.41061782836914, Delta: 2.1716308609143198e-06, Delta %: 1.749816577184959e-05, Elapsed Time: 0.0001347064971923828,  1/Elapsed Time: 7423.546902654867
True Speed: 12.519560000000002, Calculated Speed: 12.51955795288086, Delta: 2.047119142645215e-06,  Delta %: 1.63513665228268e-05,  Elapsed Time: 0.0001900196075439453,  1/Elapsed Time: 5262.614805520702</code></pre>
<p>Dit suggereert dat het merendeel van de geobserveerde fout
waarschijnlijk toe te schrijven is aan de sensor zelf en niet aan mijn
implementatie van WheelSpeedSensor. Het enige andere type fout dat
aanwezig is, betreft minimale verschillen veroorzaakt door het omzetten
van floating-point getallen naar Integers.</p>
<h2
id="integratietest-wheelspeedsensors-industriele-12v-current-modulation-interface">Integratietest:
WheelSpeedSensor’s industriele 12V Current Modulation interface</h2>
<h3 id="motivatie-1">Motivatie</h3>
<p><em>De communicatie tussen de WheelSpeedSensor en de
MeasuredSpeedCalculator is noodzakelijk voor het berekenen van de
snelheidsberekeningen.</em> <em>Als deze interface niet goed werkt,
levert dit misschien onjuiste data voor de MeasuredSpeedCalculator. Dit
zal problemen opleveren voor de hierboven genoemde Unit Test.</em>
<em>Het testen van de interface helpt om te waarborgen dat het systeem
correct functioneert en draagt bij aan de veiligheid.</em> <em>Test:
Testen of de 12V Current Modulation-interface de High/Low current
outputs van de WheelSpeedSensor correct doorstuurt naar de
MeasuredSpeedCalculator en of de MeasuredSpeedCalculator deze signalen
correct interpreteert om de snelheid van het voertuig te
berekenen.</em></p>
<p><em>### Testprocedure</em></p>
<p><em>- Zorg ervoor dat de WheelSpeedSensor en de
MeasuredSpeedCalculator correct zijn aangesloten via de 12V Current
Modulation-interface. (In ons geval is dit de C++/Python Bindings en de
communicatie hiertussen)</em> <em>- Simuleer verschillende
rotatiesnelheden van het wiel, met de WheelSpeedSensor daarop
aangesloten.</em> <em>- Monitor de High/Low current outputs die door de
WheelSpeedSensor worden gegenereerd op basis van de rotatiesnelheid van
het wiel en verifieer of deze correct worden doorgegeven via de 12V
Current Modulation-interface.</em> <em>- Controleer of de
MeasuredSpeedCalculator de ontvangen High/Low current outputs correct
interpreteert en of de berekende snelheid overeenkomt met de werkelijke
snelheid van het wiel (rekening houdend met de wieldiameter en de CPR
van het encoderwiel).</em> <em>- Voer deze test uit voor verschillende
rotatiesnelheden van het wiel om te verifiëren of de interface en de
MeasuredSpeedCalculator onder verschillende omstandigheden correct
functioneert.</em></p>
<p><em>De testprocedure controleert of de 12V Current
Modulation-interface correct werkt en of de MeasuredSpeedCalculator de
signalen nauwkeurig interpreteert. Hierdoor wordt de nauwkeurige
snelheidsberekening gegarandeerd en de veiligheid van het systeem
gewaarborgd. Het testen van verschillende rotatiesnelheden zorgt ervoor
dat het systeem onder uiteenlopende omstandigheden correct
functioneert.</em></p>
<p>HIER ONDER LEZEN HIER ONDER LEZEN HIER ONDER LEZEN HIER ONDER LEZEN
HIER ONDER LEZEN</p>
<p>Test gefaald: Dat de unit test hierboven zo goed werkt is niet voor
niets. Oorspronkelijk heb ik geprobeerd om, zoals ooit bedacht in het
projecttestplan, het hardwaredeel ‘WheelSpeedSensor’ (de ADC-achtige
Infineon-TLE5041PLUSC) en het softwaredeel
<code>MeasuredSpeedCalculator</code> apart te houden. Waar de ene enkel
waarden las, had de andere informatie over de auto Wielgrote om deze
terug te rekenen naar echte snelheid. Zoals hierboven beschreven, heb ik
eerst (via Python sockets zelfs nog) geprobeerd om met HI-LO signalen te
versturen vanuit de TrueVehicleSpeed, die dan vervolgens opgevangen
zouden moeten worden door een ander stuk Python-code. Dit werkte
absoluut niet goed. Ik heb was aan het proberen om een soort binaire
digital-to-analog-converter te maken die de timinginformatie van data
over de Python-implementatie van de sockets netwerkinterface? beheerde.
Issues hier mee was een belangrijke reden om over te schakelen naar
Redis voor betere prestaties. Hoewel dit hielp en we (na filtering en
averaging) wel een getal hadden dat gerelateerd was aan de snelheid,
varieerde dit enorm (+- 50%) en was het dus niet geschikt voor gebruik.
Dit lijkt meer een implementatiefout te zijn dan slecht ontwerp,
aangezien ik met een echte TLE5041 hardware sensor eigenlijk geforceerd
was om het zo te maken.</p>
<p>Hierdoor heb ik ervoor gekozen om de twee componenten samen te voegen
in één bestand. In plaats van HI-LO signalen slaan we nu de
‘WheelSpeedSensorHz’ op en versturen we deze als interproces-item. Door
deze abstractie toe te passen, moeten we nog steeds rekening houden met
de diameter en de encoderwiel-count. Dit komt omdat we eerst in de
simulator met de werkelijke data deze waarden moeten omrekenen naar het
aantal pulsen dat deze sensor zou uitzenden, gebaseerd op de gegeven
autospecificaties.</p>
<p>Het resultaat is dat de code hiervoor werd samengevoegd, deze is
later nog omgeschreven naar C++ voor de binding. We sturen ook data (CPR
en diameter) naar deze C++-binding, zodat we de hele berekening hierin
kunnen uitvoeren.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> WheelSpeedSensor<span class="op">::</span>read_speed<span class="op">(){</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    redisReply<span class="op">*</span> reply <span class="op">=</span> <span class="op">(</span>redisReply<span class="op">*)</span>redisCommand<span class="op">(</span>redis_client<span class="op">,</span> <span class="st">&quot;HGET Sensor_Actuator WheelSpeedSensorHz&quot;</span><span class="op">);</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> encoder_pulses_per_second <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>reply<span class="op">-&gt;</span>type <span class="op">==</span> REDIS_REPLY_STRING<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        encoder_pulses_per_second <span class="op">=</span> <span class="bu">std::</span>atof<span class="op">(</span>reply<span class="op">-&gt;</span>str<span class="op">);</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    freeReplyObject<span class="op">(</span>reply<span class="op">);</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Convert pulses per second naar rotations</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> rotations_per_second <span class="op">=</span> encoder_pulses_per_second <span class="op">/</span> <span class="kw">this</span><span class="op">-&gt;</span>cpr<span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calculate the wheel circumference we use this instead of math.h pi good enough</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> wheel_circumference <span class="op">=</span> <span class="fl">3.141592</span> <span class="op">*</span> <span class="kw">this</span><span class="op">-&gt;</span>diameter<span class="op">;</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Convert to speed in meters per second</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span> true_vehicle_speed <span class="op">=</span> rotations_per_second <span class="op">*</span> wheel_circumference<span class="op">;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> true_vehicle_speed<span class="op">;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> WheelSpeedSensor<span class="op">::</span>set_cpr<span class="op">(</span><span class="dt">float</span> cpr<span class="op">){</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">-&gt;</span>cpr <span class="op">=</span> cpr<span class="op">;</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> WheelSpeedSensor<span class="op">::</span>set_diameter<span class="op">(</span><span class="dt">float</span> diameter<span class="op">){</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">-&gt;</span>diameter <span class="op">=</span> diameter<span class="op">;</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Zoals te zien is in de loguitvoer en in
<code>/UnitTest/removedInternalError.log</code>, is het zelfs met C++
niet echt snel (varieerde tussen 5000-9000 Hz voor alleen de
read_speed()-operatie). Dit zou waarschijnlijk ook onvoldoende zijn
geweest als ik het op mijn oorspronkelijke manier had gemaakt,
waarschijnlijk niet via Redis, omdat deze te langzaam is.</p>
<pre><code>True Speed: 12.300423,          Calculated Speed: 12.30042076110839,  Elapsed Time: 0.00011110305786132812, 1/Elapsed Time: 9000.652360515021
True Speed: 12.410620000000002, Calculated Speed: 12.41061782836914,  Elapsed Time: 0.0001347064971923828,  1/Elapsed Time: 7423.546902654867
True Speed: 12.519560000000002, Calculated Speed: 12.51955795288086,  Elapsed Time: 0.0001900196075439453,  1/Elapsed Time: 5262.614805520702</code></pre>
<h2
id="systeemtest-accs-houdt-veilige-afstand-in-verschillende-verkeersscenarios">Systeemtest:
ACCS houdt Veilige afstand in verschillende verkeersscenario’s</h2>
<h3 id="motivatie-2">Motivatie</h3>
<p>Het belangrijkste doel (kwaliteitscriterium) van het ACCS is het
behouden van een veilige afstand tot het voorliggende voertuig. Het
testen van het systeem in verschillende verkeerssituaties en snelheden
helpt om te waarborgen dat het systeem correct functioneert, betrouwbaar
en veilig is, en voldoet aan de gestelde kwaliteitseisen.*</p>
<h3 id="testprocedure-1">Testprocedure</h3>
<ol type="1">
<li>Bereid verschillende verkeerssituaties en snelheden voor, die het
ACCS-systeem zou kunnen tegenkomen in real-world scenario’s (bijv.
stadsverkeer, snelwegverkeer, file, acceleratie en deceleratie, enz.).
En implementeer deze scenario’s in de Simulator.*</li>
<li>Voer de test in de simulator uit voor verschillende soorten auto’s
(Hatchback, SUV, Ferrari), voor elk van de voorbereide
verkeersscenario’s.</li>
<li>Monitor en registreer de volgende waarden tijdens elk scenario:
<ul>
<li>Afstand tot voorligger in meters*</li>
<li>MeasuredSpeed*</li>
<li>Afstand tot voorligger in seconden met de huidige
MeasuredSpeed*</li>
<li>Het verschil tussen deze laatste waarde, en de constante ‘gewenste
afstand tot voorligger in seconden’*</li>
</ul></li>
<li>Analyseer de resultaten om te bepalen of het ACCS-systeem de
ingestelde veilige afstand tot het voorliggende voertuig in alle
situaties heeft behouden.*
<ul>
<li><strong>Als de afstand tot de voorligger in meters 0 of negatief is,
betekent dit dat er een botsing is geweest; dit is per definitie dus
geen ‘veilige afstand’</strong>*</li>
</ul></li>
</ol>
<p>We hebben een PID-systeem geïmplementeerd voor de controle van onze
auto. Echter, het is zo slecht afgesteld dat het alleen effectief is
voor willekeurige testgevallen in de Ferrari. De auto’s reageren te
verschillend om dezelfde set PID-waarden te gebruiken. Ik ben hieraan
begonnen en heb zelfs een PyTorch-implementatie met een neuraal netwerk
gebruikt, dat ongeveer 15 minuten nodig had om geschikte waarden te
vinden. Desondanks is het me niet gelukt om het systeem veilig te laten
werken voor alle drie de auto’s. Omdat het wel is gelukt met de Ferrari,
lijkt dit meer een kwestie van tijd dan een systeemfout.</p>
<p>HIER ONDER LEZEN HIER ONDER LEZEN HIER ONDER LEZEN HIER ONDER LEZEN
HIER ONDER LEZEN</p>
<p>We hebben ook een simulator ontwikkeld die aangepaste testgevallen
kan uitvoeren. De invoer hiervoor is een string-gebaseerde DSL (Domain
Specific Language) die elk testgeval kan vertegenwoordigen. Elke actie
in het testgeval kan een tuple zijn, weergegeven als een string.</p>
<p>Specification: * pX: Pause for X seconds (e.g., p5 means pause for 5
seconds). * mV=X: Set myVel to X (e.g., mV=30 means set
true_vehicle_speed to 30). * mAX=X: Set myAcc to X (e.g., mAX=1 means
set true_vehicle_acceleration to 1). * vV=X: Set voVel to X (e.g., vV=20
means set true_voorligger_speed to 20). * d2v=X: Set dist2vo to X (e.g.,
d2v=100 means set true_distance_to_voorligger to 100). * cc: Check if
the vehicle has crashed and update the counters. * R: Reset the
simulation. * +=X: Increment the last float value by X. * -=X: Decrement
the last float value by X.</p>
<p>Omdat ik niet echt gemakkelijk handmatig scenarios kon bedenken voor
stadsverkeer, snelwegverkeer, file, etc, heb ik deze scenarios
automatisch laten genereren als test cases. zo is : ([9.46, 0.01, 14.24,
493.66], [‘mV=5.41’, ‘p=4.61’, ‘mV=1.54’, ‘p=4.08’, ‘cc’, ‘R’]) een
valide test scenario die automatisch gegenereerd kan worden. Zie
./SysteemTest/random_test_cases.log voor een voorbeeld van deze
testgevallen (en de code om deze te genereren).</p>
</body>
</html>
